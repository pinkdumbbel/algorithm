### 풀이 결과

품 (도움을 받아서...)

### 내가 생각한 방법

1. left i = left+1; i <= right+1; i++; 순회
2. i를 n으로 나눈 나머지가 몫+1보다 크면 나머지 push 아니면 몫+1 push
3. 몫과 나머지가 0이면 1을 push;
4. 나머지가 0 이면 n을 push

### 다른 풀이 방법

접근한 컨셉은 비슷 하지만
나는 1부터 나누는것을 생각해서 left+1 <= right+1까지 순회 했지만
다른 풀이는 left <= right까지 순회하면서 몫과 나머지를 비교 후 더 큰값에 + 1 해주는 방법으로 해결

### 다른 풀이 코드

```javascript
function solution(n, left, right) {
  var answer = [];

  for (let i = left; i <= right; i++) {
    answer.push(Math.max(i % n, parseInt(i / n)) + 1);
  }

  return answer;
}
```

### 회고

처음엔 2차원 배열로 접근하려고 했었다 그래서 안되니 1차원 배열로 해보려고 했는데
`(signal: aborted (core dumped))` 이런 런타임 에러가 발생해서 찾아보니 주어진 조건 만큼 배열 자체를 만들 수 없었다(배열의 최대 크긴 2의32승-1)

그래서 저 오류에 대해 찾다보니 해당 문제와 관련된 블로그 포스팅을 보았고 거기서 배열을 만들지 않고 풀어야 된다는 힌트를 얻었다.

얻은 힌트로 문제를 푸는데 일정한 패턴을 찾으려고 했고 패턴을 찾다보니 몫과 나머지가 일정하게 반복 되는 것을 알고 문제를 풀었다.

그런데 풀기 급급한 나머지 인덱스를 1로 잡아서 범위 자체를 1씩 증가한 상태로 순회를 하도록 풀었는데 다른 풀이를 보니 몫과 나머지를 비교해서 큰값에 +1을 해주면 되는 문제였다. 확실히 난이도가 있었다.

주어진 조건을 파악해서 어떻게 문제를 접근할 것인지 판단하는것도 아직 어렵고 그로 인해 돌아가는 부분이 있어 시간이 걸리는 부분이 아직 있다.

입력값에 대한 조건을 생각하면서 반복해서 풀다보면 시간을 많이 줄일수 있을것 같다.
